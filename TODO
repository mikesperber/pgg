+ inspect the lambda lifter (dependency analysis?)
- insert LET only if the variable appears more than once in the body
- reconsider LET insertion strategy (constructor arguments!)
- how many memoization points are really necessary?
+ support for EVAL
- complete the above (preprocessor, bta, skeleton)
+ check whether it still performs continuation-based reduction :-)
+ really generate LAMBDA_MEMO and friends
+ control memoization
+ put type annotations to work
- type annotation for arity of operators
+ handle (begin ...)
+ handle nested (define ...)
- analyze which lambdas and ctors are really memoized
- specialize project-static, project-dynamic, and friends
- use delay/force in project-* functions
+ write the library functions in direct style using shift/reset to
  achieve continuation-based reduction
+ printout mechanism for bt analyzed program?
- use introspection/reflective facilities to obtain the values of the
  free variables
- support variadic procedures (by considering argument lists as a
  special partially static datatype)
- the code generating functions return two results, the generated code
  and a synthesized attribute which indicates the "seriousness" of the
  code. The idea is that functions with non-serious body are unfolded
  on the fly. 

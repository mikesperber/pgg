;;; abstract syntax for annotated programs
;;; definitions
(define (annMakeDef name formals body)
  (vector 'DEF name formals body 'btvar 'ocs))
(define (annDefFetchProcName d)
  (vector-ref d 1)) 
(define (annDefFetchProcFormals d)
  (vector-ref d 2)) 
(define (annDefFetchProcBody d)
  (vector-ref d 3))
(define (annDefSetProcBody d body)
  (vector-set! d 3 body))
(define (annDefSetProcBTVar! d tv)
  (vector-set! d 4 tv))
(define (annDefFetchProcBTVar d)
  (vector-ref d 4))
(define (annDefFetchProcOcs d)
  (vector-ref d 5))
(define (annDefSetProcOcs! d ocs)
  (vector-set! d 5 ocs))
(define (annDefLookup name d*)
  (let loop ((d* d*))
    (and (not (null? d*))
	 (let ((d (car d*)))
	   (if (equal? (annDefFetchProcName d) name)
	       d
	       (loop (cdr d*)))))))
;;; expressions
(define (annExprFetchBTi e)
  (vector-ref e 1))
(define (annExprSetBTi! e bt)
  (vector-set! e 1 bt))
(define (annExprFetchBTo e)
  (vector-ref e 2))
(define (annExprSetBTo! e bt)
  (vector-set! e 2 bt))
(define (annExprFetchLevel e)
  (vector-ref e 3))
(define (annExprSetLevel! e lv)
  (vector-set! e 3 lv))
;;; variable
(define (annMakeVar v)
  (vector 'VAR #f #f 0 v 'dummy))
(define (annIsVar? e)
  (equal? 'VAR (vector-ref e 0)))
(define (annFetchVar e)
  (vector-ref e 4))
;;; constant
(define (annMakeConst c)
  (vector 'CONST #f #f 0 c 'dummy))
(define (annIsConst? e)
  (equal? 'CONST (vector-ref e 0)))
(define (annFetchConst e)
  (vector-ref e 4))
;;; conditional
(define (annMakeCond e-cond e-then e-else)
  (vector 'CONDITION #f #f 0 e-cond e-then e-else))
(define (annIsCond? e)
  (equal? 'CONDITION (vector-ref e 0)))
(define (annFetchCondTest e)
  (vector-ref e 4))
(define (annFetchCondThen e)
  (vector-ref e 5))
(define (annFetchCondElse e)
  (vector-ref e 6))
;;; primitive operation
(define (annMakeOp op args)
  (vector 'OP #f #f 0 op args #t))
(define (annMakeOpaqueOp op args)
  (vector 'OP #f #f 0 op args #f))
(define (annIsOp? e)
  (equal? 'OP (vector-ref e 0)))
(define (annFetchOpName e)
  (vector-ref e 4))
(define (annFetchOpArgs e)
  (vector-ref e 5))
(define (annFetchOpDiscardability e)
  (vector-ref e 6))
;;; procedure call
(define (annMakeCall fname args)
  (vector 'CALL #f #f 0 fname args))
(define (annIsCall? e)
  (equal? 'CALL (vector-ref e 0)))
(define (annFetchCallName e)
  (vector-ref e 4))
(define (annFetchCallArgs e)
  (vector-ref e 5))
;;; let, one variable
(define (annMakeLet v e1 e2)
  (vector 'LET #f #f 0 v e1 e2 #f))
(define (annIsLet? e)
  (equal? 'LET (vector-ref e 0)))
(define (annFetchLetVar e)
  (vector-ref e 4))
(define (annFetchLetHeader e)
  (vector-ref e 5))
(define (annFetchLetBody e)
  (vector-ref e 6))
(define (annFetchLetUnfoldability e)
  (vector-ref e 7))
(define (annSetLetUnfoldability! e prop)
  (vector-set! e 7 prop))
;;; lambda
(define (annMakeLambda label formals body)
  (vector 'LAMDBA #f #f 0 formals body label))
(define (annIsLambda? e)
  (equal? 'LAMDBA (vector-ref e 0)))
(define (annFetchLambdaVars e)
  (vector-ref e 4))
(define (annFetchLambdaBody e)
  (vector-ref e 5))
(define (annSetLambdaBody! e body)
  (vector-set! e 5 body))
(define (annFetchLambdaLabel e)
  (vector-ref e 6))
;;; application
(define (annMakeApp rator rands)
  (vector 'APPLY #f #f 0 rator rands))
(define (annIsApp? e)
  (equal? 'APPLY (vector-ref e 0)))
(define (annFetchAppRator e)
  (vector-ref e 4))
(define (annFetchAppRands e)
  (vector-ref e 5))
;;; constructor
(define (annMakeCtor ctor desc args)
  (vector 'CTOR #f #f 0 ctor desc args))
(define (annMakeCtor1 desc)
  (lambda (ctor args) (annMakeCtor ctor desc args)))
(define (annIsCtor? e)
  (equal? 'CTOR (vector-ref e 0)))
(define (annFetchCtorName e)
  (vector-ref e 4))
(define (annFetchCtorDesc e)
  (vector-ref e 5))
(define (annFetchCtorArgs e)
  (vector-ref e 6))
;;; selector
(define (annMakeSel ctor-sel desc sel arg)
  (vector 'SEL #f #f 0 ctor-sel desc sel arg))
(define (annMakeSel1 ctor desc sel)
  (lambda (ctor-sel args)
    (annMakeSel ctor-sel desc sel (car args))))
(define (annIsSel? e)
  (equal? 'SEL (vector-ref e 0)))
(define (annFetchSelName e)
  (vector-ref e 4))
(define (annFetchSelDesc e)
  (vector-ref e 5))
(define (annFetchSelComp e)
  (vector-ref e 6))
(define (annFetchSelArg e)
  (vector-ref e 7))
;;; constructor test
(define (annMakeTest ctor-test desc arg)
  (vector 'TEST #f #f 0 ctor-test desc arg))
(define (annMakeTest1 ctor desc)
  (lambda (ctor-test args) (annMakeTest ctor-test desc (car args))))
(define (annIsTest? e)
  (equal? 'TEST (vector-ref e 0)))
(define (annFetchTestName e)
  (vector-ref e 4))
(define (annFetchTestDesc e)
  (vector-ref e 5))
(define (annFetchTestArg e)
  (vector-ref e 6))
;;; special form:
(define (annMakeEval eval args)
  (vector 'EVAL #f #f 0 (car args) 0 #f))
(define (annIsEval? e)
  (equal? 'EVAL (vector-ref e 0)))
(define (annFetchEvalBody e)
  (vector-ref e 4))
(define (annFetchEvalDiff e)
  (vector-ref e 5))
(define (annSetEvalDiff! e ld)
  (vector-set! e 5 ld))
(define (annFetchEvalQuoted e)
  (vector-ref e 6))
(define (annSetEvalQuoted! e b)
  (vector-set! e 6 b))
;;; subject to discussion:
;;; lift
(define (annIntroduceLift e lv ld)
  (let ((body (list->vector (vector->list e))))
    (vector-set! e 0 'LIFT)
    (vector-set! e 3 lv)
    (vector-set! e 2 ld)
    (vector-set! e 1 body)))
(define (annIsLift? e)
  (equal? 'LIFT (vector-ref e 0)))
(define (annSetLiftDiff! e ld)
  (vector-set! e 2 ld))
(define (annFetchLiftDiff e)
  (vector-ref e 2))
(define (annFetchLiftBody e)
  (vector-ref e 1))
;;; subject to discussion:
;;; memoization
(define (annIntroduceMemo e lv vars)
  (annIntroduceMemo1 e lv vars (list->vector (vector->list e))))
(define (annIntroduceMemo1 e lv vars body)    
  (vector-set! e 0 'MEMO)
  (vector-set! e 3 lv)
  (vector-set! e 2 vars)
  (vector-set! e 1 body))
(define (annMakeMemo body)
  (vector 'MEMO body '() 0))
(define (annIsMemo? e)
  (equal? 'MEMO (vector-ref e 0)))
(define (annSetMemoVars! e args)
  (vector-set! e 2 args))
(define (annFetchMemoVars e)
  (vector-ref e 2))
(define (annFetchMemoBody e)
  (vector-ref e 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (annFreeVars e)
  (let loop ((e e))
    (cond
     ((annIsVar? e)
      (list e))
     ((annIsConst? e)
      '())
     ((annIsCond? e)
      (var-union (loop (annFetchCondTest e))
		 (loop (annFetchCondThen e))
		 (loop (annFetchCondElse e))))
     ((annIsOp? e)
      (apply var-union (map loop (annFetchOpArgs e))))
     ((annIsCall? e)
      (apply var-union (map loop (annFetchCallArgs e))))
     ((annIsLet? e)
      (var-union (loop (annFetchLetHeader e))
	     (var-difference (loop (annFetchLetBody e))
			     (list (annFetchLetVar e)))))
     ((annIsLambda? e)
      (var-difference (loop (annFetchLambdaBody e))
		      (annFetchLambdaVars e)))
     ((annIsApp? e)
      (apply var-union (cons (loop (annFetchAppRator e))
			     (map loop (annFetchAppRands e)))))
     ((annIsCtor? e)
      (apply var-union (map loop (annFetchCtorArgs e))))
     ((annIsSel? e)
      (loop (annFetchSelArg e)))
     ((annIsTest? e)
      (loop (annFetchTestArg e)))
     ((annIsLift? e)
      (loop (annFetchLiftBody e)))
     ((annIsEval? e)
      (loop (annFetchEvalBody e)))
     ((annIsMemo? e)
      (loop (annFetchMemoBody e)))
     (else
      (error 'annFreeVars "Unknown syntax construction")))))
 
(define (var-member v vs)
  (let ((vname (annFetchVar v)))
    (var-member-1 vname vs)))
(define (var-member-1 vname vs)
    (let loop ((vs vs))
      (if (null? vs)
	  #f
	  (or (equal? (annFetchVar (car vs)) vname)
	      (loop (cdr vs))))))

(define (var-union . args)
  (if (null? args)
      '()
      (let ((s1 (car args))
	    (s2 (apply var-union (cdr args))))
	(let loop ((s1 s1))
	  (if (null? s1)
	      s2
	      (if (var-member (car s1) s2)
		  (loop (cdr s1))
		  (cons (car s1) (loop (cdr s1)))))))))
(define (var-member-2 v vv)
  (let ((vname (annFetchVar v)))
    (let loop ((vv vv))
      (if (null? vv)
	  #f
	  (or (equal? vname (car vv))
	      (loop (cdr vv))))))) 

(define (var-difference vs1 vv2)
  (let  loop ((vs1 vs1))
    (if (null? vs1)
	'()
	(if (var-member-2 (car vs1) vv2)
	    (loop (cdr vs1))
	    (cons (car vs1) (loop (cdr vs1)))))))
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (annExprTerminates? e)
  (let loop ((e e))
    (cond
     ((annIsVar? e)
      #t)
     ((annIsConst? e)
      #t)
     ((annIsCond? e)
      (and (loop (annFetchCondTest e))
	   (loop (annFetchCondThen e))
	   (loop (annFetchCondElse e))))
     ((annIsOp? e)
      (and (annFetchOpDiscardability e)
	   (andmap loop (annFetchOpArgs e))))
     ((annIsCall? e)
      #f)
     ((annIsLet? e)
      (and (loop (annFetchLetHeader e))
	   (loop (annFetchLetBody e))))
     ((annIsLambda? e)
      #t)
     ((annIsApp? e)
      #f)
     ((annIsCtor? e)
      (andmap loop (annFetchCtorArgs e)))
     ((annIsSel? e)
      (loop (annFetchSelArg e)))
     ((annIsTest? e)
      (loop (annFetchTestArg e)))
     ((annIsLift? e)
      #t)
     ((annIsEval? e)
      (loop (annFetchEvalBody e)))
     ((annIsMemo? e)
      (loop (annFetchMemoBody e)))
     (else
      (error 'annExprTerminates? "Unknown syntax construction")))))
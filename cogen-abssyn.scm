;;; abstract syntax for annotated programs
;;; definitions
(define (annMakeDef name formals body)
  (vector 'DEF name formals body 'btvar))
(define (annDefFetchProcName d)
  (vector-ref d 1)) 
(define (annDefFetchProcFormals d)
  (vector-ref d 2)) 
(define (annDefFetchProcBody d)
  (vector-ref d 3))
(define (annDefSetProcBTVar! d tv)
  (vector-set! d 4 tv))
(define (annDefFetchProcBTVar d)
  (vector-ref d 4))
(define (annDefLookup name d*)
  (let loop ((d* d*))
    (let ((d (car d*)))
      (if (equal? (annDefFetchProcName d) name)
	  d
	  (loop (cdr d*))))))
;;; expressions
(define (annExprFetchBTi e)
  (vector-ref e 1))
(define (annExprSetBTi! e bt)
  (vector-set! e 1 bt))
(define (annExprFetchBTo e)
  (vector-ref e 2))
(define (annExprSetBTo! e bt)
  (vector-set! e 2 bt))
(define (annExprFetchLevel e)
  (vector-ref e 3))
(define (annExprSetLevel! e lv)
  (vector-set! e 3 lv))
;;; variable
(define (annMakeVar v)
  (vector 'VAR #f #f 0 v 'dummy))
(define (annIsVar? e)
  (equal? 'VAR (vector-ref e 0)))
(define (annFetchVar e)
  (vector-ref e 4))
;;; constant
(define (annMakeConst c)
  (vector 'CONST #f #f 0 c 'dummy))
(define (annIsConst? e)
  (equal? 'CONST (vector-ref e 0)))
(define (annFetchConst e)
  (vector-ref e 4))
;;; conditional
(define (annMakeCond e-cond e-then e-else)
  (vector 'CONDITION #f #f 0 e-cond e-then e-else))
(define (annIsCond? e)
  (equal? 'CONDITION (vector-ref e 0)))
(define (annFetchCondTest e)
  (vector-ref e 4))
(define (annFetchCondThen e)
  (vector-ref e 5))
(define (annFetchCondElse e)
  (vector-ref e 6))
;;; primitive operation
(define (annMakeOp op args)
  (vector 'OP #f #f 0 op args))
(define (annIsOp? e)
  (equal? 'OP (vector-ref e 0)))
(define (annFetchOpName e)
  (vector-ref e 4))
(define (annFetchOpArgs e)
  (vector-ref e 5))
;;; procedure call
(define (annMakeCall fname args)
  (vector 'CALL #f #f 0 fname args))
(define (annIsCall? e)
  (equal? 'CALL (vector-ref e 0)))
(define (annFetchCallName e)
  (vector-ref e 4))
(define (annFetchCallArgs e)
  (vector-ref e 5))
;;; let, one variable
(define (annMakeLet v e1 e2)
  (vector 'LET #f #f 0 v e1 e2))
(define (annIsLet? e)
  (equal? 'LET (vector-ref e 0)))
(define (annFetchLetVar e)
  (vector-ref e 4))
(define (annFetchLetHeader e)
  (vector-ref e 5))
(define (annFetchLetBody e)
  (vector-ref e 6))
;;; lambda
(define (annMakeLambda formals body)
  (vector 'LAMDBA #f #f 0 formals body))
(define (annIsLambda? e)
  (equal? 'LAMDBA (vector-ref e 0)))
(define (annFetchLambdaVars e)
  (vector-ref e 4))
(define (annFetchLambdaBody e)
  (vector-ref e 5))
;;; application
(define (annMakeApp rator rands)
  (vector 'APPLY #f #f 0 rator rands))
(define (annIsApp? e)
  (equal? 'APPLY (vector-ref e 0)))
(define (annFetchAppRator e)
  (vector-ref e 4))
(define (annFetchAppRands e)
  (vector-ref e 5))
;;; constructor
(define (annMakeCtor ctor desc args)
  (vector 'CTOR #f #f 0 ctor desc args))
(define (annMakeCtor1 desc)
  (lambda (ctor args) (annMakeCtor ctor desc args)))
(define (annIsCtor? e)
  (equal? 'CTOR (vector-ref e 0)))
(define (annFetchCtorName e)
  (vector-ref e 4))
(define (annFetchCtorDesc e)
  (vector-ref e 5))
(define (annFetchCtorArgs e)
  (vector-ref e 6))
;;; selector
(define (annMakeSel ctor desc sel arg)
  (vector 'SEL #f #f 0 ctor desc sel arg))
(define (annMakeSel1 ctor desc sel)
  (lambda (fake-sel args) (vector 'SEL #f #f 0 ctor desc sel (car args))))
(define (annIsSel? e)
  (equal? 'SEL (vector-ref e 0)))
(define (annFetchSelName e)
  (vector-ref e 4))
(define (annFetchSelDesc e)
  (vector-ref e 5))
(define (annFetchSelComp e)
  (vector-ref e 6))
(define (annFetchSelArg e)
  (vector-ref e 7))
;;; constructor test
(define (annMakeTest ctor desc arg)
  (vector 'TEST #f #f 0 ctor desc arg))
(define (annMakeTest1 ctor desc)
  (lambda (fake-test args) (annMakeTest ctor desc (car args))))
(define (annIsTest? e)
  (equal? 'TEST (vector-ref e 0)))
(define (annFetchTestName e)
  (vector-ref e 4))
(define (annFetchTestDesc e)
  (vector-ref e 5))
(define (annFetchTestArg e)
  (vector-ref e 6))
;;; subject to discussion:
;;; lift
(define (annIntroduceLift e lv ld)
  (let ((body (list->vector (vector->list e))))
    (vector-set! e 0 'LIFT)
    (vector-set! e 3 lv)
    (vector-set! e 2 ld)
    (vector-set! e 1 body)))
(define (annIsLift? e)
  (equal? 'LIFT (vector-ref e 0)))
(define (annSetLiftDiff! e ld)
  (vector-set! e 2 ld))
(define (annFetchLiftDiff e)
  (vector-ref e 2))
(define (annFetchLiftBody e)
  (vector-ref e 1))
;;; subject to discussion:
;;; memoization
(define (annIntroduceMemo e lv vars)
  (let ((body (list->vector (vector->list e))))
    (vector-set! e 0 'MEMO)
    (vector-set! e 3 lv)
    (vector-set! e 2 vars)
    (vector-set! e 1 body)))
(define (annMakeMemo body)
  (vector 'MEMO body '() 0))
(define (annIsMemo? e)
  (equal? 'MEMO (vector-ref e 0)))
(define (annSetMemoVars! e args)
  (vector-set! e 2 args))
(define (annFetchMemoVars e)
  (vector-ref e 2))
(define (annFetchMemoBody e)
  (vector-ref e 1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (annFreeVars e)
  (let loop ((e e))
    (cond
     ((annIsVar? e)
      (list e))
     ((annIsConst? e)
      '())
     ((annIsCond? e)
      (var-union (loop (annFetchCondTest e))
		 (loop (annFetchCondThen e))
		 (loop (annFetchCondElse e))))
     ((annIsOp? e)
      (apply var-union (map loop (annFetchOpArgs e))))
     ((annIsCall? e)
      (apply var-union (map loop (annFetchCallArgs e))))
     ((annIsLet? e)
      (var-union (loop (annFetchLetHeader e))
	     (var-difference (loop (annFetchLetBody e))
			     (list (annFetchLetVar e)))))
     ((annIsLambda? e)
      (var-difference (loop (annFetchLambdaBody e))
		      (annFetchLambdaVars e)))
     ((annIsApp? e)
      (apply var-union (cons (loop (annFetchAppRator e))
			     (map loop (annFetchAppRands e)))))
     ((annIsCtor? e)
      (apply var-union (map loop (annFetchCtorArgs e))))
     ((annIsSel? e)
      (loop (annFetchSelArg e)))
     ((annIsTest? e)
      (loop (annFetchTestArg e)))
     ((annIsLift? e)
      (loop (annFetchLiftBody e)))
     ((annIsMemo? e)
      (loop (annFetchMemoBody e))))))
 
(define (var-member v vs)
  (let ((vname (annFetchVar v)))
    (var-member-1 vname vs)))
(define (var-member-1 vname vs)
    (let loop ((vs vs))
      (if (null? vs)
	  #f
	  (or (equal? (annFetchVar (car vs)) vname)
	      (loop (cdr vs))))))

(define (var-union . args)
  (if (null? args)
      '()
      (let ((s1 (car args))
	    (s2 (apply var-union (cdr args))))
	(let loop ((s1 s1))
	  (if (null? s1)
	      s2
	      (if (var-member (car s1) s2)
		  (loop (cdr s1))
		  (cons (car s1) (loop (cdr s1)))))))))
(define (var-member-2 v vv)
  (let ((vname (annFetchVar v)))
    (let loop ((vv vv))
      (if (null? vv)
	  #f
	  (or (equal? vname (car vv))
	      (loop (cdr vv))))))) 

(define (var-difference vs1 vv2)
  (let  loop ((vs1 vs1))
    (if (null? vs1)
	'()
	(if (var-member-2 (car vs1) vv2)
	    (loop (cdr vs1))
	    (cons (car vs1) (loop (cdr vs1)))))))
 

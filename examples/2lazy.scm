(define-data desc
  (const const->value)
  (cvar  cvar->number)
  (static-susp static-susp->ref-sum)	; (value + unit -> value) ref
  (dyn-susp dyn-static->ref-sum dyn-susp->ref-sum))
(define-data xpair
  (xcons xcar xcdr)
  (xnil))
(define-data values
  (basic basic->value)
  (fail))
(define-data maybe
  (just just->one)
  (nothing))
(define-data sum
  (make-value sum->value)
  (make-thunk sum->thunk))

(define (lazy-2int prg goal xs* xd*)
  (let* ((goal-proc (prg-lookup goal prg))
	 (formals (proc->formals goal-proc))
	 (denv (input->desc-env formals xs*))
	 (nr-cvars (input->nr-cvars xs*))
	 (cenv (input->cvenv xd* nr-cvars))
	 (expr (proc->expr goal-proc)))
    (lazy-2eval prg denv cenv expr)))

(define (lazy-2eval prg denv cenv expr)

  (define (static-eval denv expr)
    ;;(display (list "static-eval" denv expr)) (newline)
    (cond
     ((constant-expr? expr)
      (basic (constant->value expr)))
     ((var-expr? expr)
      (let ((desc (apply-denv denv (var->name expr))))
	(cond
	 ((const? desc)
	  (basic (const->value desc)))
	 ((static-susp? desc)
	  (let* ((ref (static-susp->ref-sum desc))
		 (sum (cell-ref ref)))
	    (if (make-value? sum)
		(sum->value sum)
		(let ((new-value ((sum->thunk sum))))
		  (cell-set! ref (make-value new-value))
		  new-value))))
	 ((dyn-susp? desc)
	  (let* ((sref (dyn-static->ref-sum desc))
		 (ssum (cell-ref sref)))
	    (if (make-value? ssum)
		(sum->value ssum)
		(let ((new-svalue ((sum->thunk ssum))))
		  (cell-set! sref (make-value new-svalue))
		  new-svalue))))
	 ;; remaining cases are dynamic: [dyn-susp], cvar
	 (else
	  (fail)))))
     ((cond-expr? expr)
      (let ((value (static-eval denv (cadr expr))))
	(if (fail? value)
	    (fail)
	    (if (basic->value value)
		(static-eval denv (caddr expr))
		(static-eval denv (cadddr expr))))))
     ((binop-expr? expr)
      (let ((op (car expr)))
	(let ((value1 (static-eval denv (cadr expr))))
	  (if (fail? value1)
	      (fail)
	      (let ((value2 (static-eval denv (caddr expr))))
		(if (fail? value2)
		    (fail)
		    (basic (static-ext op
				(basic->value value1)
				(basic->value value2)))))))))
     ((funcall-expr? expr)
      (let* ((f (car expr))
	     (args (cdr expr))
	     (f-proc (prg-lookup f prg))
	     (formals (proc->formals f-proc))
	     (body (proc->expr f-proc)))
	(let ((maybe-denv (static-construct-denv denv formals args)))
	  (if (nothing? maybe-denv)
	      (fail)
	      (static-eval (just->one maybe-denv) body)))))
     (else
      (static-error "syntax error: illegal expression"
		    expr))))
  
  (define (static-construct-denv denv formals args)
    (let loop ((formals formals) (args args))
      (if (null? args)
	  (just (initial-denv))
	  (let ((expr (car args))
		(name (car formals))
		(args (cdr args))
		(formals (cdr formals)))
	    (let ((maybe-denv (loop formals args)))
	      (if (nothing? maybe-denv)
		  (nothing)
		  (let ((new-denv (just->one maybe-denv))
			(entry
			 (cond
			  ((var-expr? expr)
			   (apply-denv denv (var->name expr)))
			  ((constant-expr? expr)
			   (const (constant->value expr)))
			  (else
			   (static-susp
			    (make-cell
			     (make-thunk (lambda () (static-eval denv expr)))))))))
		    (just (enter-denv name entry new-denv)))))))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (define (dynamic-eval denv cenv expr)
    (cond
     ((constant-expr? expr)
      (constant->value expr))
     ((var-expr? expr)
      (let ((desc (apply-denv denv (var->name expr))))
	(cond
	 ((const? desc)
	  (const->value desc))
	 ((dyn-susp? desc)
	  (let* ((sref (dyn-static->ref-sum desc))
		 (ssum (cell-ref sref))
		 (svalue
		  (if (make-value? ssum)
		      (sum->value ssum)
		      (let ((new-svalue ((sum->thunk ssum))))
			(cell-set! sref (make-value new-svalue))
			new-svalue))))
	    (if (basic? svalue)
		(basic->value svalue)
		(let* ((ref (dyn-susp->ref-sum desc))
		       (sum (cell-ref ref)))
		  (if (make-value? sum)
		      (sum->value sum)
		      (let ((new-value ((sum->thunk sum))))
			(cell-set! ref (make-value new-value))
			new-value))))))
	 ((cvar? desc)
	  (apply-cenv cenv (cvar->number desc))))))
     ((cond-expr? expr)
      (let ((value (static-eval denv (cadr expr))))
	(if (basic? value)
	    (if (basic->value value)
		(dynamic-eval denv cenv (caddr expr))
		(dynamic-eval denv cenv (cadddr expr)))
	    ;; static evaluation of the condition fails, try dynamically
	    (if (dynamic-eval denv cenv (cadr expr))
		(lazy-2eval prg denv cenv (caddr expr))
		(lazy-2eval prg denv cenv (cadddr expr))))))
     ((binop-expr? expr)
      (ext (car expr)
	   (lazy-2eval prg denv cenv (cadr expr))
	   (lazy-2eval prg denv cenv (caddr expr))))
     ((funcall-expr? expr)
      (let* ((f (car expr))
	     (args (cdr expr))
	     (f-proc (prg-lookup f prg))
	     (formals (proc->formals f-proc))
	     (body (proc->expr f-proc)))
	(let loop ((formals formals)
		   (args args)
		   (new-denv (initial-denv)))
	  (if (null? formals)
	      (lazy-2eval prg new-denv cenv body)
	      (let ((name (car formals))
		    (formals (cdr formals))
		    (expr (car args))
		    (args (cdr args)))
		(let ((entry
		       (cond
			((var-expr? expr)
			 (apply-denv denv (var->name expr)))
			((constant-expr? expr)
			 (const (constant->value expr)))
			(else
			 (dyn-susp
			  (make-cell
			   (make-thunk
			    (lambda () (static-eval denv expr))))
			  (make-cell
			   (make-thunk
			    (lambda () (lazy-2eval prg denv cenv expr)))))))))
		  (loop formals args (enter-denv name entry new-denv))))))))
     (else
      (static-error "syntax error: illegal expression"
		    expr))))

  (let ((static-result (static-eval denv expr)))
    (if (fail? static-result)
	(dynamic-eval denv cenv expr)
	(basic->value static-result))))

(define (input->desc-env names xs*)
  (if (null? xs*)
      (initial-denv)
      (let ((xs (car xs*))
	    (name (car names))
	    (xs* (cdr xs*))
	    (names (cdr names)))
	(let ((desc-env (input->desc-env names xs*)))
	  (if (and (pair? xs) (equal? (car xs) 'CV))
	      (enter-denv name (cvar (cadr xs)) desc-env)
	      (enter-denv name (const xs) desc-env))))))



(define (input->cvenv xd* nr)
  (if (zero? nr)
      (initial-cenv)
      (let loop ((i 1) (xd* xd*) (cenv (initial-cenv)))
	(cond
	 ((= i nr)
	  (enter-cenv i (car xd*) cenv))
	 (else
	  (loop (+ i 1) (cdr xd*) (enter-cenv i (car xd*) cenv)))))))

(define (initial-denv) (xnil))
(define (enter-denv key value xenv)
  (xcons (xcons key value) xenv))
(define (apply-denv xenv key)
  (let loop ((xenv xenv))
    (if (xnil? xenv)
	(static-error "key not found" key)
	(let* ((entry (xcar xenv)))
	  (if (equal? (xcar entry) key)
	      (xcdr entry)
	      (loop (xcdr xenv)))))))

(define (initial-cenv) (xnil))
(define (enter-cenv key value xenv)
  (xcons (xcons key value) xenv))
(define (apply-cenv xenv key)
  (let loop ((xenv xenv))
    (if (xnil? xenv)
	(static-error "key not found" key)
	(let* ((entry (xcar xenv)))
	  (if (equal? (xcar entry) key)
	      (xcdr entry)
	      (loop (xcdr xenv)))))))

(define (ext op arg1 arg2)
  (case op
    ((+) (+ arg1 arg2))
    ((-) (- arg1 arg2))
    ((*) (* arg1 arg2))
    ((/) (/ arg1 arg2))
    ((cons) (cons arg1 arg2))
    ((bin-car) (car arg1))
    ((bin-cdr) (cdr arg1))
    ((equal?) (equal? arg1 arg2))
    (else 'undefined-primitive)))
E ::=	K | (quote A) | V | (if E E E) | (cond (E E)* (else E)?) |
	(O E*) | (P E*) | (begin E*)
	(let ((V E)*) D0* E*) | (let* ((V E)*) D0* E*) |
	(letrec ((V (lambda (V*) E*))*) D0* E*) |
	(let P ((V E)*) D0* E*) |
	(case E ((A*) E*)* (else E*)?) |
	(lambda (V*) D0* E*) | (E E*) |
	[ (lambda V D0* E*) | (lambda (V* . V) D0* E*) | ]
	(C E*) | (Ci E) | (C? E) |		% constructors, selectors, tests
	(M B E)					% a memoization point at level B
A ::=   <datum> of R4RS
D0 ::=  (define (P V*) D0* E*)
D ::=	D0 |
	(define P D0* E*) |			% not allowed for goal procedure
	(defdata T (C Ci*)+) |
	(define-type (P B*) B) |
	(define-operator O d) |
	(define-operator (O B*) B) |
	(defmemo M [only])			% "only" present => standard memoization off
B ::=	* | d | -
prg ::= D+


S ::=   (P G*)					% syntax of the skeleton call
G ::=	* | - | d | s | <number> | ((C G*)*)	% binding times in the skeleton
